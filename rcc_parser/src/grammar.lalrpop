use std::str::FromStr;
use crate::ast::*;

grammar;

pub Expr: Expr = {
    Or,
};

Or: Expr = {
    <lhs: Or> "||" < rhs: And> => Expr::Binary(BinOp::Or , Box::new(lhs), Box::new(rhs)),
    And,
};

And: Expr = {
    <lhs: And> "&&" < rhs: Equality> => Expr::Binary(BinOp::And , Box::new(lhs), Box::new(rhs)),
    Equality,
};

Equality: Expr = {
    <lhs: Relational> "==" < rhs: Relational> => Expr::Binary(BinOp::Eq , Box::new(lhs), Box::new(rhs)),
    <lhs: Relational> "!=" < rhs: Relational> => Expr::Binary(BinOp::Ne , Box::new(lhs), Box::new(rhs)),
    Relational,
};

Relational: Expr = {
    <lhs: Add> "<" < rhs: Add> => Expr::Binary(BinOp::Lt , Box::new(lhs), Box::new(rhs)),
    <lhs: Add> "<=" < rhs: Add> => Expr::Binary(BinOp::Le , Box::new(lhs), Box::new(rhs)),
    <lhs: Add> ">" < rhs: Add> => Expr::Binary(BinOp::Lt , Box::new(rhs), Box::new(lhs)),
    <lhs: Add> ">=" < rhs: Add> => Expr::Binary(BinOp::Le , Box::new(rhs), Box::new(lhs)),
    Add,
};

Add: Expr = {
    <lhs: Add> "+" < rhs: Mul> => Expr::Binary(BinOp::Add , Box::new(lhs), Box::new(rhs)),
    <lhs: Add> "-" < rhs: Mul> => Expr::Binary(BinOp::Sub , Box::new(lhs), Box::new(rhs)),
    Mul,
};

Mul: Expr = {
    <lhs: Mul> "*" < rhs: Unary> => Expr::Binary(BinOp:: Mul, Box::new(lhs), Box::new(rhs)),
    <lhs: Mul> "/" < rhs: Unary> => Expr::Binary(BinOp:: Div, Box::new(lhs), Box::new(rhs)),
    Unary,
};

Unary: Expr = {
    "-" <p: Primary> => Expr::Unary(UnOp::Neg, Box::new(p)),
    Primary,
};

Primary: Expr = {
    Int => Expr::Int(<>),
    Bool => Expr::Bool(<>),
    "(" <Expr> ")",
};

Int: u64 = {
    r"[0-9]+" => u64::from_str(<>).unwrap(),
};

Bool: bool = {
    TokTrue => true,
    TokFalse => false,
}

match {
    r"true" => TokTrue,
    r"false" => TokFalse,
} else {
    _,
}
